It would be better not to reimplement this complex logic every time you want to display a notification.

Furthermore, I assume you would like a global notifications store: you are good to go with a global actor to handle notifications!

Actors are not a shiny way to make code look smart: it's an excellent way to split code into business logic chunks.

Nick Worrall uses actor model a lot. For him, the actor model is safer and prevents unwanted side effects from happening. He tries to keep his state machines as small as possible to scope independent behaviors. He would only have a few machines with 50 states, but he would have a system of 50 little state machines.

### Split generic features

We can not only split state machines by independent features but also split them to make some generic mechanisms reusable.

**37%** of respondents split machines into **reusable utility machines**.

A great example is a machine to fetch data. Fetching data seems trivial, but it becomes a lot more complex when implementing things like caching or revalidation that specialized tools do, like TanStack Query.

The internal working of [TanStack Query](https://tanstack.com/query/latest) (previously known as React Query) is impressive and could be implemented as a state machine.

You wouldn't want to implement revalidation when the user re-focuses the window for every HTTP call you make inside your state machines; it's more well-suited to extract this logic into a reusable `requestMachine`, that could support beneath any RPC protocol.
